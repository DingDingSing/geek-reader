#### 排序

- 基础排序算法 时间复杂度预览

| 排序算法 | 时间复杂度 |
| :------: | :--------: |
|   冒泡   |   单元格   |
|  单元格  |   单元格   |


- 如何分析一个排序算法
  - 排序算法的执行效率
    - 最好、最坏、平均时间复杂度
    - 时间复杂度的系数、常数、低阶
      - 对同一阶的时间复杂度对比、需要加入系数、常数、低阶进行对比
      - 比较次数、和交换(移动)次数
  - 排序算法的内存消耗
    - >原地排序: 空间复杂度为 O(1) 的算法。
  - 排序算法的稳定性
    - 稳定排序算法 排序之后相同数据的位置不变化
    - 不稳定排序算法
      - 例子: 根据金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序排列
        - 方案: 先按照时间进行从早到晚排序,使用稳定的排序方法进行金额大小排序

- 插入排序
  - > 核心思想:  取未排序区间的元素、在已排序区间中找到合适的插入位置将其插入、并保证已排序区间数据一致有序、重复这个过程、知道未排序区间中元素为空。

```js
function insert_sort(a: number[]) {
  for (let i = 1; i < a.length; i++) {
    insert_helper(a, i, a[i]);
  }
}

function insert_helper(a: number[], i: number, x: number) {
  // 循环不变式
  // P 指向 下一个要比较的元素

  let p = i - 1;

  while (p >= 0 && a[p] > x) {
    a[p + 1] = a[p];
    p--;
    
  }
  a[p + 1] = x;
}
```