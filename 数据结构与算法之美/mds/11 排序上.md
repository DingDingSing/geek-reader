#### 排序

- 基础排序算法 时间复杂度预览

| 排序算法 | 时间复杂度 |
| :------: | :--------: |
|   冒泡   |   单元格   |
|  单元格  |   单元格   |


- 如何分析一个排序算法
  - 排序算法的执行效率
    - 最好、最坏、平均时间复杂度
    - 时间复杂度的系数、常数、低阶
      - 对同一阶的时间复杂度对比、需要加入系数、常数、低阶进行对比
      - 比较次数、和交换(移动)次数
  - 排序算法的内存消耗
    - >原地排序: 空间复杂度为 O(1) 的算法。
  - 排序算法的稳定性
    - 稳定排序算法 排序之后相同数据的位置不变化
    - 不稳定排序算法
      - 例子: 根据金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序排列
        - 方案: 先按照时间进行从早到晚排序,使用稳定的排序方法进行金额大小排序


### 冒泡排序

```ts
function swap(a: number[], i: number, j: number) {
  const x = a[i];
  a[i] = a[j];
  a[j] = x;
}

function bubble_sort(a: number[]) {
  // 外层循环 i
  // 内层循环 j
  //
  for (let i = a.length - 1; i >= 1; i--) {
    // 内层循环
    for (let j = 1; j <= i; j++) {
      a[j - 1] > a[j] && swap(a, j - 1, j);
    }
  }
}
```
问题：
  - 冒泡排序是原地排序么
    - 是、空间复杂度 O(1) ？ 其中不是设计临时变量保存么
  - 冒泡排序是稳定排序么
    - 是、两个元素相等时、不进行位置交换
  - 冒泡排序的时间复杂度是多少
    - 最好 O(1)
    - 最坏 $O(n^2)$
    - 平均时间复杂度
      - 有序度、 逆序度
      - > 有序度: 数组中具有 有序关系 的元素对的个数
      - > 满有序度: 完全有序数组的的有序度叫满有序度
      - > 逆序度: 和有序度相反
      - 例如: [2,4,3,1,5,6]
        - 有序度: 11 
        - 满有序度: $n*(n-1)/2 = 15$
        - 逆有序度: 15 - 11 = 4
      - 排序的过程就是增加有序度、减少逆有序度的过程、达到满有序度、排序就完成了。
      - 冒泡排序包含比较和交换两种原子操作,每交换一次、有序度就+1、不管怎么改进、交换次数总是不变的。
      - 最好情况、交换次数为0 、 最坏情况下交换次数为 $n*(n-1)/2$、取一个平均值: $N*(n-1)/4$
    - 平均时间复杂度为 $o(n^2)$

### 插入排序
  - > 核心思想:  取未排序区间的元素、在已排序区间中找到合适的插入位置将其插入、并保证已排序区间数据一致有序、重复这个过程、知道未排序区间中元素为空。

```ts
function insert_sort(a: number[]) {
  for (let i = 1; i < a.length; i++) {
    insert_helper(a, i, a[i]);
  }
}

function insert_helper(a: number[], i: number, x: number) {
  // 循环不变式
  // P 指向 下一个要比较的元素

  let p = i - 1;

  while (p >= 0 && a[p] > x) {
    a[p + 1] = a[p];
    p--;
    
  }
  a[p + 1] = x;
}
```

- 问题
  - 插入排序是原地排序么
    - 是、空间复杂度 O(1)
  - 插入排序是稳定排序么
    - 是、两个元素相等时、不进行数据插入
  - 插入排序的时间复杂度是多少
    - 最好 O(1)
    - 最坏 $O(n^2)$
    - 平均时间复杂度 $O(n^2)$

### 选择排序